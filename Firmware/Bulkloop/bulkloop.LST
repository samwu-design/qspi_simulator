C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 1   


C51 COMPILER V6.12, COMPILATION OF MODULE BULKLOOP
OBJECT MODULE PLACED IN .\bulkloop.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE .\bulkloop.c DEBUG OBJECTEXTEND

stmt level    source

   1          //-----------------------------------------------------------------------------
   2          //   File:      bulkloop.c
   3          //   Contents:  Hooks required to implement USB peripheral function.
   4          //
   5          // $Archive: /USB/Examples/FX2LP/bulkloop/bulkloop.c $
   6          //
   7          //
   8          //-----------------------------------------------------------------------------
   9          // Copyright (c) 2011, Cypress Semiconductor Corporation All rights reserved
  10          //-----------------------------------------------------------------------------
  11          #pragma NOIV               // Do not generate interrupt vectors
  12          
  13          #include "..\inc\fx2.h"
  14          #include "..\inc\fx2regs.h"
  15          #include "..\inc\syncdly.h"            // SYNCDELAY macro
  16          
  17          extern BOOL GotSUD;             // Received setup data flag
  18          extern BOOL Sleep;
  19          extern BOOL Rwuen;
  20          extern BOOL Selfpwr;
  21          
  22          BYTE Configuration;             // Current configuration
  23          BYTE AlternateSetting;          // Alternate settings
  24          
  25          // sam add
  26          
  27          //------end sam add
  28          
  29          #define VR_NAKALL_ON    0xD0
  30          #define VR_NAKALL_OFF   0xD1
  31          
  32          //-----------------------------------------------------------------------------
  33          // Task Dispatcher hooks
  34          //   The following hooks are called by the task dispatcher.
  35          //-----------------------------------------------------------------------------
  36          
  37          void TD_Init(void)             // Called once at startup
  38          {
  39   1      
  40   1      
  41   1         // set the CPU clock to 48MHz
  42   1         CPUCS = ((CPUCS & ~bmCLKSPD) | bmCLKSPD1) ;
  43   1      	SYNCDELAY;
  44   1      
  45   1         REVCTL = 0x03; // REVCTL.0 and REVCTL.1 to set to 1
  46   1      	SYNCDELAY;  
  47   1      
  48   1         // [7] IFCLKSRC: 0- EXTEND 1-INTERNAL;[6] 30/48: 0-30MHZ 1-48MHZ; [5]IFCLKOE:0-IN 1-OUT; [4]IFCLKPOL: 0
  49   1         // [3] ASYNC:0-SYNC 1-ASYNC; [2]G_STATE 0-XX 1-PORT[0:2]; [1:0] IFCFG:00-PORT 01-RSV 11-SLAVE FIFO
  50   1         //IFCONFIG |= 0x43; // set the slave FIFO interface to 48MHz / slave fifo
  51   1      	//IFCONFIG |= 0x53; // IFCLK 48MHz / IFCLK REVERT/ slave fifo
  52   1      	//IFCONFIG |= 0x13; // IFCLK 30MHz/ IFCLK REVERT / slave fifo
  53   1         IFCONFIG |= 0xE3; // 1110 0011  INTERNAL CLK  OUTPUT OE SLAVE FIFO
  54   1      	SYNCDELAY;	 
  55   1      
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 2   

  56   1        // Registers which require a synchronization delay, see section 15.14
  57   1        // FIFORESET        FIFOPINPOLAR
  58   1        // INPKTEND         OUTPKTEND
  59   1        // EPxBCH:L         REVCTL
  60   1        // GPIFTCB3         GPIFTCB2
  61   1        // GPIFTCB1         GPIFTCB0
  62   1        // EPxFIFOPFH:L     EPxAUTOINLENH:L
  63   1        // EPxFIFOCFG       EPxGPIFFLGSEL
  64   1        // PINFLAGSxx       EPxFIFOIRQ
  65   1        // EPxFIFOIE        GPIFIRQ
  66   1        // GPIFIE           GPIFADRH:L
  67   1        // UDMACRCH:L       EPxGPIFTRIG
  68   1        // GPIFTRIG
  69   1        
  70   1        // Note: The pre-REVE EPxGPIFTCH/L register are affected, as well...
  71   1        //      ...these have been replaced by GPIFTC[B3:B0] registers
  72   1      
  73   1        // default: all endpoints have their VALID bit set
  74   1        // default: TYPE1 = 1 and TYPE0 = 0 --> BULK  
  75   1        // default: EP2 and EP4 DIR bits are 0 (OUT direction)
  76   1        // default: EP6 and EP8 DIR bits are 1 (IN direction)
  77   1        // default: EP2, EP4, EP6, and EP8 are double buffered
  78   1      
  79   1      
  80   1        // we are just using the default values, yes this is not necessary...
  81   1        // see TRM section 15.14
  82   1        
  83   1        //EP2CFG = 0xA0;                // OUT  valid bulk 512B 4buf
  84   1        EP2CFG = 0xA8;                // OUT  valid bulk 1024B 4buf
  85   1        //EP2CFG = 0xA2;                  // OUT  valid bulk 512B 2buf
  86   1        SYNCDELAY;                    
  87   1        
  88   1        //EP4CFG = 0xA0;                // OUT  valid 512B 2BUF
  89   1        //SYNCDELAY;                    
  90   1        //EP6CFG = 0x7f;                // IN   invalid
  91   1        //SYNCDELAY;                    
  92   1        //EP8CFG = 0x7f;                // IN   invalid
  93   1        //SYNCDELAY;
  94   1      
  95   1      
  96   1        FIFORESET = 0x80; // Reset the FIFO
  97   1        SYNCDELAY;
  98   1        FIFORESET = 0x82;
  99   1        SYNCDELAY;
 100   1        FIFORESET = 0x00;
 101   1        SYNCDELAY;
 102   1      
 103   1        OUTPKTEND = 0x82;  //
 104   1        SYNCDELAY;
 105   1        OUTPKTEND = 0x82;  //
 106   1        SYNCDELAY;
 107   1        OUTPKTEND = 0x82;  //
 108   1        SYNCDELAY;
 109   1        OUTPKTEND = 0x82;  //
 110   1        SYNCDELAY;
 111   1        // 
 112   1        //SYNCDELAY;
 113   1        //EP2FIFOCFG = 0x00;              // AUTO=0, WORDWIDE=0(0-8bit 1-16bits)                    
 114   1        EP2FIFOCFG = 0x11;              // AUTO=1, WORDWIDE=1
 115   1        SYNCDELAY;
 116   1      
 117   1        //EP4FIFOCFG = 0x11;              // AUTO=1, WORDWIDE=1
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 3   

 118   1        //SYNCDELAY;  
 119   1              
 120   1        //EP6FIFOCFG = 0x00;              // AUTO=0, WORDWIDE=0
 121   1        //SYNCDELAY;                    
 122   1        //EP6FIFOCFG = 0x0D;              // AUTO=1, WORDWIDE=1
 123   1        //SYNCDELAY;
 124   1                      
 125   1      
 126   1      	// [7:4] flagb: 
 127   1      	// [3:0] flaga:
 128   1      	//  0100-EP2PF  0101-EP4PF 0110-EP6PF 0111-EP8PF
 129   1         //  1000-EP2EF  1001-EP4EF 1010EP6EF  1011-EP8EF
 130   1      	//  1100-EP2FF  1101-EP4FF 1110-EP6FF 1111-EP8FF
 131   1      	//  OTHER-RSV
 132   1         PINFLAGSAB = 0xC8;     // FLAGB - fixed EP2FF FLAGA - EP2EF  
 133   1         SYNCDELAY;
 134   1      
 135   1         PINFLAGSCD = 0xDE;     // FLAGD - unvalid  FLAGC - fixed EP6FF
 136   1         SYNCDELAY;
 137   1      
 138   1         PORTACFG = 0x40;       // func of PA7 pin is SLCS#
 139   1         SYNCDELAY;
 140   1      
 141   1         FIFOPINPOLAR = 0x00;   // ACTIVE LOW
 142   1      	SYNCDELAY;
 143   1      
 144   1        // out endpoints do not come up armed
 145   1        
 146   1        // since the defaults are double buffered we must write dummy byte counts twice
 147   1                         
 148   1      //  EP2BCL = 0x80;                // arm EP2OUT by writing byte count w/skip.
 149   1      //  SYNCDELAY;                                        
 150   1      //  EP2BCL = 0x80;
 151   1      //  SYNCDELAY;
 152   1      //  EP2BCL = 0x80;
 153   1      //  SYNCDELAY;
 154   1      //  EP2BCL = 0x80;
 155   1      //  SYNCDELAY;                  
 156   1      
 157   1        //EP4BCL = 0x80;
 158   1        //SYNCDELAY;                  
 159   1        //EP4BCL = 0x80;
 160   1        //SYNCDELAY;
 161   1      
 162   1      
 163   1                         
 164   1        //EP2FIFOBCL = 0x00;
 165   1        //SYNCDELAY;
 166   1        //EP2FIFOBCH = 0x04;
 167   1        //SYNCDELAY;   
 168   1      
 169   1        // enable dual autopointer feature
 170   1        //AUTOPTRSETUP |= 0x01;
 171   1        //SYNCDELAY;
 172   1      
 173   1      
 174   1      }
 175          
 176          
 177          void TD_Poll(void)              // Called repeatedly while the device is idle
 178          {
 179   1      /*  
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 4   

 180   1      WORD count;
 181   1        WORD  i;
 182   1      
 183   1      
 184   1      // no code necessary to xfr data from host to master! AUTOOUT=1 auto-commits packets
 185   1      if (!(EP2468STAT & bmEP2EMPTY))
 186   1      {
 187   1      	APTR1H = MSB( &EP2FIFOBUF ); // Initializing the first data pointer
 188   1      	SYNCDELAY;
 189   1      	APTR1L = LSB( &EP2FIFOBUF ); 
 190   1      	SYNCDELAY;
 191   1      	count = (EP2BCH << 8) + EP2BCL; // The count value is loaded from the byte
 192   1         // count registers
 193   1      	for( i = 0x0000; i < count; i++ )
 194   1      	{
 195   1      	// setup to transfer EP2OUT buffer to EP6IN buffer using AUTOPOINTER(s)
 196   1      	//EXTAUTODAT2 = EXTAUTODAT1;
 197   1      	} 
 198   1      
 199   1      	
 200   1         EP2BCL = 0x80; // re (arm) EP2OUT
 201   1      
 202   1         SYNCDELAY;
 203   1      }
 204   1      
 205   1      
 206   1      */
 207   1      
 208   1      /*
 209   1        WORD i;
 210   1        WORD count;
 211   1      
 212   1        if(!(EP2468STAT & bmEP2EMPTY))
 213   1        { // check EP2 EMPTY(busy) bit in EP2468STAT (SFR), core set's this bit when FIFO is empty
 214   1           if(!(EP2468STAT & bmEP6FULL))
 215   1           {  // check EP6 FULL(busy) bit in EP2468STAT (SFR), core set's this bit when FIFO is full
 216   1              APTR1H = MSB( &EP2FIFOBUF );
 217   1              APTR1L = LSB( &EP2FIFOBUF );
 218   1      
 219   1              AUTOPTRH2 = MSB( &EP6FIFOBUF );
 220   1              AUTOPTRL2 = LSB( &EP6FIFOBUF );
 221   1      
 222   1              count = (EP2BCH << 8) + EP2BCL;
 223   1      
 224   1              // loop EP2OUT buffer data to EP6IN
 225   1              for( i = 0x0000; i < count; i++ )
 226   1              {
 227   1                 // setup to transfer EP2OUT buffer to EP6IN buffer using AUTOPOINTER(s)
 228   1                 EXTAUTODAT2 = EXTAUTODAT1;
 229   1              }
 230   1              EP6BCH = EP2BCH;  
 231   1              SYNCDELAY;  
 232   1              EP6BCL = EP2BCL;        // arm EP6IN
 233   1              SYNCDELAY;                    
 234   1              EP2BCL = 0x80;          // re(arm) EP2OUT
 235   1           }
 236   1        }
 237   1      
 238   1        if(!(EP2468STAT & bmEP4EMPTY))
 239   1        { // check EP4 EMPTY(busy) bit in EP2468STAT (SFR), core set's this bit when FIFO is empty
 240   1           if(!(EP2468STAT & bmEP8FULL))
 241   1           {  // check EP8 FULL(busy) bit in EP2468STAT (SFR), core set's this bit when FIFO is full
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 5   

 242   1              APTR1H = MSB( &EP4FIFOBUF );
 243   1              APTR1L = LSB( &EP4FIFOBUF );
 244   1      
 245   1              AUTOPTRH2 = MSB( &EP8FIFOBUF );
 246   1              AUTOPTRL2 = LSB( &EP8FIFOBUF );
 247   1      
 248   1              count = (EP4BCH << 8) + EP4BCL;
 249   1      
 250   1              // loop EP4OUT buffer data to EP8IN
 251   1              for( i = 0x0000; i < count; i++ )
 252   1              {
 253   1                 // setup to transfer EP4OUT buffer to EP8IN buffer using AUTOPOINTER(s)
 254   1                 EXTAUTODAT2 = EXTAUTODAT1;
 255   1              }
 256   1              EP8BCH = EP4BCH;  
 257   1              SYNCDELAY;  
 258   1              EP8BCL = EP4BCL;        // arm EP8IN
 259   1              SYNCDELAY;                    
 260   1              EP4BCL = 0x80;          // re(arm) EP4OUT
 261   1           }
 262   1        }
 263   1      */
 264   1      }
 265          
 266          BOOL TD_Suspend(void)          // Called before the device goes into suspend mode
 267          {
 268   1         return(TRUE);
 269   1      }
 270          
 271          BOOL TD_Resume(void)          // Called after the device resumes
 272          {
 273   1         return(TRUE);
 274   1      }
 275          
 276          //-----------------------------------------------------------------------------
 277          // Device Request hooks
 278          //   The following hooks are called by the end point 0 device request parser.
 279          //-----------------------------------------------------------------------------
 280          
 281          BOOL DR_GetDescriptor(void)
 282          {
 283   1         return(TRUE);
 284   1      }
 285          
 286          BOOL DR_SetConfiguration(void)   // Called when a Set Configuration command is received
 287          {
 288   1         Configuration = SETUPDAT[2];
 289   1         return(TRUE);            // Handled by user code
 290   1      }
 291          
 292          BOOL DR_GetConfiguration(void)   // Called when a Get Configuration command is received
 293          {
 294   1         EP0BUF[0] = Configuration;
 295   1         EP0BCH = 0;
 296   1         EP0BCL = 1;
 297   1         return(TRUE);            // Handled by user code
 298   1      }
 299          
 300          BOOL DR_SetInterface(void)       // Called when a Set Interface command is received
 301          {
 302   1         AlternateSetting = SETUPDAT[2];
 303   1         return(TRUE);            // Handled by user code
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 6   

 304   1      }
 305          
 306          BOOL DR_GetInterface(void)       // Called when a Set Interface command is received
 307          {
 308   1         EP0BUF[0] = AlternateSetting;
 309   1         EP0BCH = 0;
 310   1         EP0BCL = 1;
 311   1         return(TRUE);            // Handled by user code
 312   1      }
 313          
 314          BOOL DR_GetStatus(void)
 315          {
 316   1         return(TRUE);
 317   1      }
 318          
 319          BOOL DR_ClearFeature(void)
 320          {
 321   1         return(TRUE);
 322   1      }
 323          
 324          BOOL DR_SetFeature(void)
 325          {
 326   1         return(TRUE);
 327   1      }
 328          
 329          BOOL DR_VendorCmnd(void)
 330          {
 331   1        BYTE tmp;
 332   1        
 333   1        switch (SETUPDAT[1])
 334   1        {
 335   2           case VR_NAKALL_ON:
 336   2              tmp = FIFORESET;
 337   2              tmp |= bmNAKALL;      
 338   2              SYNCDELAY;                    
 339   2              FIFORESET = tmp;
 340   2              break;
 341   2           case VR_NAKALL_OFF:
 342   2              tmp = FIFORESET;
 343   2              tmp &= ~bmNAKALL;      
 344   2              SYNCDELAY;                    
 345   2              FIFORESET = tmp;
 346   2              break;
 347   2           default:
 348   2              return(TRUE);
 349   2        }
 350   1      
 351   1        return(FALSE);
 352   1      }
 353          
 354          //-----------------------------------------------------------------------------
 355          // USB Interrupt Handlers
 356          //   The following functions are called by the USB interrupt jump table.
 357          //-----------------------------------------------------------------------------
 358          
 359          // Setup Data Available Interrupt Handler
 360          void ISR_Sudav(void) interrupt 0
 361          {
 362   1         GotSUD = TRUE;            // Set flag
 363   1         EZUSB_IRQ_CLEAR();
 364   1         USBIRQ = bmSUDAV;         // Clear SUDAV IRQ
 365   1      }
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 7   

 366          
 367          // Setup Token Interrupt Handler
 368          void ISR_Sutok(void) interrupt 0
 369          {
 370   1         EZUSB_IRQ_CLEAR();
 371   1         USBIRQ = bmSUTOK;         // Clear SUTOK IRQ
 372   1      }
 373          
 374          void ISR_Sof(void) interrupt 0
 375          {
 376   1         EZUSB_IRQ_CLEAR();
 377   1         USBIRQ = bmSOF;            // Clear SOF IRQ
 378   1      }
 379          
 380          void ISR_Ures(void) interrupt 0
 381          {
 382   1         // whenever we get a USB reset, we should revert to full speed mode
 383   1         pConfigDscr = pFullSpeedConfigDscr;
 384   1         ((CONFIGDSCR xdata *) pConfigDscr)->type = CONFIG_DSCR;
 385   1         pOtherConfigDscr = pHighSpeedConfigDscr;
 386   1         ((CONFIGDSCR xdata *) pOtherConfigDscr)->type = OTHERSPEED_DSCR;
 387   1      
 388   1         EZUSB_IRQ_CLEAR();
 389   1         USBIRQ = bmURES;         // Clear URES IRQ
 390   1      }
 391          
 392          void ISR_Susp(void) interrupt 0
 393          {
 394   1         Sleep = TRUE;
 395   1         EZUSB_IRQ_CLEAR();
 396   1         USBIRQ = bmSUSP;
 397   1      }
 398          
 399          void ISR_Highspeed(void) interrupt 0
 400          {
 401   1         if (EZUSB_HIGHSPEED())
 402   1         {
 403   2            pConfigDscr = pHighSpeedConfigDscr;
 404   2            ((CONFIGDSCR xdata *) pConfigDscr)->type = CONFIG_DSCR;
 405   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 406   2            ((CONFIGDSCR xdata *) pOtherConfigDscr)->type = OTHERSPEED_DSCR;
 407   2         }
 408   1      
 409   1         EZUSB_IRQ_CLEAR();
 410   1         USBIRQ = bmHSGRANT;
 411   1      }
 412          void ISR_Ep0ack(void) interrupt 0
 413          {
 414   1      }
 415          void ISR_Stub(void) interrupt 0
 416          {
 417   1      }
 418          void ISR_Ep0in(void) interrupt 0
 419          {
 420   1      }
 421          void ISR_Ep0out(void) interrupt 0
 422          {
 423   1      }
 424          void ISR_Ep1in(void) interrupt 0
 425          {
 426   1      }
 427          void ISR_Ep1out(void) interrupt 0
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 8   

 428          {
 429   1      }
 430          void ISR_Ep2inout(void) interrupt 0
 431          {
 432   1      }
 433          void ISR_Ep4inout(void) interrupt 0
 434          {
 435   1      }
 436          void ISR_Ep6inout(void) interrupt 0
 437          {
 438   1      }
 439          void ISR_Ep8inout(void) interrupt 0
 440          {
 441   1      }
 442          void ISR_Ibn(void) interrupt 0
 443          {
 444   1      }
 445          void ISR_Ep0pingnak(void) interrupt 0
 446          {
 447   1      }
 448          void ISR_Ep1pingnak(void) interrupt 0
 449          {
 450   1      }
 451          void ISR_Ep2pingnak(void) interrupt 0
 452          {
 453   1      	EZUSB_IRQ_CLEAR();
 454   1          NAKIRQ = bmEP2PING;
 455   1      }
 456          void ISR_Ep4pingnak(void) interrupt 0
 457          {
 458   1      }
 459          void ISR_Ep6pingnak(void) interrupt 0
 460          {
 461   1      }
 462          void ISR_Ep8pingnak(void) interrupt 0
 463          {
 464   1      }
 465          void ISR_Errorlimit(void) interrupt 0
 466          {
 467   1      }
 468          void ISR_Ep2piderror(void) interrupt 0
 469          {
 470   1      }
 471          void ISR_Ep4piderror(void) interrupt 0
 472          {
 473   1      }
 474          void ISR_Ep6piderror(void) interrupt 0
 475          {
 476   1      }
 477          void ISR_Ep8piderror(void) interrupt 0
 478          {
 479   1      }
 480          void ISR_Ep2pflag(void) interrupt 0
 481          {
 482   1      }
 483          void ISR_Ep4pflag(void) interrupt 0
 484          {
 485   1      }
 486          void ISR_Ep6pflag(void) interrupt 0
 487          {
 488   1      }
 489          void ISR_Ep8pflag(void) interrupt 0
C51 COMPILER V6.12  BULKLOOP                                                               08/03/2022 09:05:05 PAGE 9   

 490          {
 491   1      }
 492          void ISR_Ep2eflag(void) interrupt 0
 493          {
 494   1      }
 495          void ISR_Ep4eflag(void) interrupt 0
 496          {
 497   1      }
 498          void ISR_Ep6eflag(void) interrupt 0
 499          {
 500   1      }
 501          void ISR_Ep8eflag(void) interrupt 0
 502          {
 503   1      }
 504          void ISR_Ep2fflag(void) interrupt 0
 505          {
 506   1      }
 507          void ISR_Ep4fflag(void) interrupt 0
 508          {
 509   1      }
 510          void ISR_Ep6fflag(void) interrupt 0
 511          {
 512   1      }
 513          void ISR_Ep8fflag(void) interrupt 0
 514          {
 515   1      }
 516          void ISR_GpifComplete(void) interrupt 0
 517          {
 518   1      }
 519          void ISR_GpifWaveform(void) interrupt 0
 520          {
 521   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    500    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
